# Lab5-for-Java

Лабораторная работа 5. Вариант 6. Выполняла: Кужлева Любовь ИТ-17-2024/ИКНТ/ЛА8-2024/ПР4-2024.

Данная работа разделена на 7 блоков, каждый из который реализован с помощью конструкции switch. 
Каждое задание имеет полное описание для вывода на экран. 
В классе Main5 реализована работа программы с дружественным интерфейсом. 
В главном классе Main используется единственный метод класса Main5 для демонстрации работы программы.

1. Шаблон.

Используемые классы: SolveFraction, Fraction, FractionProxy.

В данном задании необходимо было добавить интерфейс к классу дроби, который релизует два новых метода:
получение вещественного значения, установка числителя и установка знаменателя.
Затем нужно было релизовать шаблон таким образом, чтобы можно было кэшировать дробь.
Для того, чтобы реализовать работу данного задания, я выбрала паттерн прокси (Proxy).
Идея паттерна «Заместитель(прокси)» заключается в предоставлении клиенту другого объекта (заместителя),
взамен объекту с контролируемым доступом. При этом, объект-заместитель, реализует тот-же интерфейс,
что и оригинальный объект, в результате чего, поведение клиента не требует изменений.
Иными словами, клиент взаимодействует с заместителем ровно как с оригинальным объектом посредством единого интерфейса.
Клиент, так же, не делает предположений о том работает ли он с реальным объектом или его заместителем.
Контролирование доступа к объекту, при этом, достигается за счет использования ссылки на него в заместителе,
благодаря которой заместитель переадресовывает внешние вызовы контролируемому объекту,
возможно сопровождая их дополнительными операциями.
Так, в классе FractionProxy используется ссылка на элемент класса SolveFraction.
В реализации класса FractionProxy также демонстрируется работа с кэшем,
для каждого шага работы задачи показано, полн ли кэш на данный момент или пуст.

2. Структурный шаблон.

Используемые классы: Cat,MeowManager,Meowing,CountingCatDecorator.

В данном задании необоходимо было посчитать количество мяуканьий кота
за всю работу задания, причем изменять уже реализованный класс нельзя.
Для того, чтобы реализовать рабоут данного задания, я выбрала паттерн декоратор (decorator).
Паттерн «Декоратор» позволяет динамически добавлять объекту новые обязанности,
не прибегая при этом к порождению классов. При этом, работа с подобной структурой
является более удобной и гибкой, нежели со множеством классов. Для этого, ссылка
на декорируемый объект помещается в другой класс, называемый «Декоратором».
Причем, и декоратор и декорируемый объект реализуют один и тот-же интерфейс,
что позволяет вкладывать несколько декораторов друг в друга, добавляя тем самым 
декорируемому объекту любое число новых обязанностей.
Декоратор переадресует внешние вызовы декорируему объекту сопровождая их наложением дополнительных обязанностей.
В реализации класса CountingCatDecorator добавляется новое поле meowCount,
подсчитывающее количество мяуканий при каждом вызове метода meow,
а также соответсвующий метод toString, который выводит количество мяуканий за всю работу задания.
  
3. Список.

Используемые классы: ListOfValues.

В данном задании необходимо было реализовать программу,
которая изменяет содержимое списка по определённому правилу.
Задача заключалась в том, чтобы в некотором списке L после
заданного элемента E вставить все элементы этого же списка,
но только в том случае, если элемент E действительно содержится в списке.
Метод, отвечающий за выполнение описанного действия, сначала ищет индекс
первого вхождения указанного элемента E в списке. Если элемент найден,
программа формирует несколько дополнительных списков: один содержит весь исходный список целиком,
второй — элементы, стоящие до элемента E, и третий — элементы, расположенные после него.
После этого исходный список очищается, а затем в него поочередно добавляются новые данные
в следующем порядке: сначала элементы, стоящие до элемента E, затем сам элемент E,
после него — весь исходный список целиком, и в конце — оставшиеся элементы, стоящие после E.
В результате программа формирует обновлённый список, который по сути содержит все прежние элементы,
но с вставкой полного списка после указанного элемента.
Таким образом, размер списка увеличивается примерно в два раза, сохраняя при этом исходный порядок элементов.
Если же элемент E отсутствует в списке, программа не выполняет никаких изменений,
и исходный список возвращается в первоначальном виде. 
Для реализации данной функциональности использовались обобщения (Generics).
Обобщённые типы и методы позволяют создавать универсальные и типобезопасные классы,
которые можно использовать с любыми типами данных, не теряя при этом гибкости и не дублируя код.

  
4. Мап.

Используемые классы: Maps, students.

В данном задании необходимо было реализовать работу программы,
которая читает данные о студентах из текстового файла, сохраняет их в коллекцию
и выводит на экран список тех учащихся, которые соответствуют определённым условиям.
Файл, из которого производится чтение, называется Students.
В первой строке этого файла хранится количество студентов,
а в последующих строках содержатся сведения о каждом из них в формате:
фамилия, имя и три числовых значения, обозначающих количество баллов, набранных за экзамены. 
Программа открывает файл с помощью BufferedReader и FileReader, затем считывает первую строку,
преобразуя её в целое число, которое определяет, сколько записей о студентах нужно обработать.
После этого происходит последовательное чтение данных о каждом студенте.
Каждая строка разбивается на части методом split(" "), и из полученного массива строк формируется
полное имя студента и массив из трёх оценок. Эти данные помещаются в коллекцию типа HashMap,
где ключом является строка с именем студента, а значением — массив целых чисел с тремя оценками.
После того как все данные считаны и сохранены, программа проходит по элементам коллекции.
Для каждого студента вычисляется сумма трёх экзаменов, а также проверяется выполнение условий:
каждый экзамен должен иметь не менее 30 баллов, а общая сумма должна быть не меньше 140.
Если студент удовлетворяет этим критериям, его имя и фамилия выводятся на экран.
Одновременно подсчитывается количество студентов, соответствующих условиям отбора.
В конце работы программы выводится количество студентов, удовлятворяющих всем условиям.

5. Сет.

Используемые классы: Sets, realPoetry*.

В данной задаче была реализована программа, которая позволяет определить,
какие буквы русского алфавита отсутствуют в заданном тексте.
Программа состоит из двух основных методов.
Метод getCharacters осуществляет чтение содержимого файла с помощью FileReader
и сохраняет все встречающиеся символы в множество Set<Character>.
Для корректной работы с русским текстом файл открывается с кодировкой UTF-8.
Содержимое файла читается посимвольно и формируется в строку, которая
затем преобразуется в нижний регистр, чтобы игнорировать различия между заглавными и строчными буквами.
После этого каждый символ добавляется в множество,
что позволяет получить уникальный набор всех символов, встречающихся в тексте.
Метод count использует полученное множество символов для анализа отсутствующих букв.
Сначала создаётся множество всех букв русского алфавита, после чего из него удаляются все символы,
присутствующие в тексте. В результате остаются только те буквы, которых нет в тексте.
Программа выводит на экран количество отсутствующих букв, а также сам список этих букв.
Использование коллекций Set позволило легко выполнять операции над множествами,
такие как удаление элементов одного множества из другого, что особенно удобно при работе с уникальными символами.
Кроме того, применение метода toLowerCase гарантирует,
что различие между заглавными и строчными буквами не повлияет на результат подсчета.
*txt файл.

6. Очередь.

Используемые классы: Queues.

В данной задаче была реализована программа, которая позволяет по заданному списку
элементов построить очередь с определённой структурой.
Задача заключалась в том, чтобы по списку L сформировать очередь таким образом,
чтобы в начале находились элементы исходного списка, а после них — те же элементы,
расположенные в обратном порядке. Например, для списка [1, 2, 3] результатом должна была стать очередь [1, 2, 3, 3, 2, 1].
Для реализации данной функциональности был использован интерфейс Queue с конкретной реализацией через класс LinkedList,
который позволяет эффективно добавлять элементы в конец очереди и извлекать их с начала.
Метод buildQueue сначала создаёт очередь на основе исходного списка,
добавляя в неё все элементы в том порядке, в котором они находятся в списке.
Затем программа проходит по списку в обратном порядке и добавляет каждый элемент в конец очереди.
В результате формируется очередь, содержащая сначала исходные элементы, а затем их копии в обратном порядке.
Для вывода элементов очереди использовался вспомогательный метод showQueue,
который последовательно извлекает элементы с помощью метода poll и выводит их на экран.
При реализации использовались обобщённые типы (Generics), что позволило сделать
метод универсальным и применимым к спискам, содержащим элементы любого типа данных. 
  
7. Стрим.

Используемые классы: Point, Line, Polyline, BuildPolyline

В данном задании реализуется работа с набором объектов типа Point для построения ломаной линии,
представленной объектом типа Polyline. Основная цель заключается в том, чтобы из исходного списка
точек выбрать только уникальные точки с различными координатами,
упорядочить их по координате X и преобразовать отрицательные значения Y в положительные.
Для выполнения задачи используется класс BuildPolyline, метод которого принимает на вход список точек.
Внутри метода применяется Stream API, что позволяет удобно и лаконично выполнять последовательные операции над набором данных.
Сначала формируется поток точек, при этом все точки с отрицательными координатами Y преобразуются к положительным значениям.
Далее выполняется фильтрация для удаления повторяющихся точек с одинаковыми координатами X и Y.
После этого оставшиеся точки сортируются по координате X, а результат собирается в новый список объектов Point.
В конце метод возвращает объект типа Polyline.
Использование Stream API значительно упрощает реализацию:
операции фильтрации, сортировки и преобразования данных выполняются в виде цепочки вызовов.

Используемые классы: Stream2, humans*

В данном задании реализуется обработка текстового файла humans, который содержит данные в формате «Имя:Номер».
Цель программы заключалась в том, чтобы объединить данные по номерам, при этом имена
с одинаковыми номерами формировали список, а записи без номера исключались из обработки.
Для выполнения задачи используется класс Stream2, метод groupBy,
который считывает содержимое файла и формирует результат в виде Map,
где ключом выступает номер, а значением — список имён, соответствующих этому номеру.
Сначала с помощью Stream API происходит фильтрация данных: исключаются пустые строки и строки, не содержащие символ «:».
Далее каждая строка разделяется на две части, первая из которых соответствует имени, а вторая — номеру.
Для корректного представления имени применяется метод formatName, который приводит имя к нижнему регистру и делает первую букву заглавной.
После обработки данные собираются в мап, используя Collectors.groupingBy, где ключом становится номер, а значением — список имён, связанных с этим номером.
В результате получается структура, в которой все имена, относящиеся к одному номеру,
объединены в один список, а некорректные или неполные записи автоматически отбрасываются
*txt файл.

Тестирование.

Функциональное.
1. 
<img width="484" height="555" alt="image" src="https://github.com/user-attachments/assets/6185c417-bf8c-40ac-b5b8-7c6ccf6b5f8f" />
<img width="543" height="371" alt="image" src="https://github.com/user-attachments/assets/501c94ec-bea2-4f09-a3e2-78ebaca7054f" />
<img width="529" height="517" alt="image" src="https://github.com/user-attachments/assets/4bd83cef-6475-4cb9-9085-87b93080727c" />
<img width="517" height="486" alt="image" src="https://github.com/user-attachments/assets/bda8930c-f663-4fa7-ab3e-dcab60be255a" />
<img width="632" height="602" alt="image" src="https://github.com/user-attachments/assets/d8342745-d1a0-4489-8c2f-a883ecdc7949" />
<img width="464" height="426" alt="image" src="https://github.com/user-attachments/assets/23a6adef-1c35-426c-917a-25d059811115" />

2.
<img width="479" height="177" alt="image" src="https://github.com/user-attachments/assets/f15fd68e-694a-4b19-81c7-31684b2a27e2" />
<img width="480" height="228" alt="image" src="https://github.com/user-attachments/assets/6882f003-c0c4-4798-aac3-fbe836f4da38" />
<img width="465" height="291" alt="image" src="https://github.com/user-attachments/assets/42104f1b-344e-4192-ae3b-ceceea24c9d4" />

3.
<img width="561" height="361" alt="image" src="https://github.com/user-attachments/assets/87252574-2955-4a17-b6d0-6fdda54d6f70" />
<img width="643" height="326" alt="image" src="https://github.com/user-attachments/assets/5316763f-ec25-475c-bb6a-433b1fc4a3b7" />
<img width="603" height="406" alt="image" src="https://github.com/user-attachments/assets/27ec9e15-1429-41ae-bbb4-b6e92626865c" />

4. Вывод данных для демонстрации корректности.
<img width="667" height="358" alt="image" src="https://github.com/user-attachments/assets/309b7cec-fbd8-4e01-a34a-39b26742a850" />
<img width="438" height="162" alt="image" src="https://github.com/user-attachments/assets/40dbb0ac-a360-4c89-9d7d-5ae918ca34d8" />
<img width="302" height="139" alt="image" src="https://github.com/user-attachments/assets/9860c386-f8b7-4de3-9f84-dc183e33f436" />

5. 
<img width="491" height="674" alt="image" src="https://github.com/user-attachments/assets/67b43b2b-64b3-4255-aeaa-b7f2d225fb3f" />
<img width="1098" height="454" alt="image" src="https://github.com/user-attachments/assets/ae42adec-3c12-44c4-b0d9-9ff2e32e0a87" />
<img width="1091" height="769" alt="image" src="https://github.com/user-attachments/assets/b48807d9-5055-49dd-84f7-5a29cf1562de" />
<img width="1252" height="757" alt="image" src="https://github.com/user-attachments/assets/cf8fde55-bf83-4ac9-866a-da0574dc7ac3" />
<img width="1157" height="731" alt="image" src="https://github.com/user-attachments/assets/0d829531-6e4d-4bc3-be57-e54f475cf4fc" />
наличие остальных букв также можно проверить в текстовом редакторе :)

6. 
<img width="702" height="629" alt="image" src="https://github.com/user-attachments/assets/80ad5943-2bfd-4f1b-a31b-b3e43ee7a573" />
<img width="737" height="292" alt="image" src="https://github.com/user-attachments/assets/2043ce29-3ea7-4c58-a6cf-e97d9d477774" />
<img width="687" height="373" alt="image" src="https://github.com/user-attachments/assets/1e04cbcb-f05b-4b7e-a283-e21e17ac8a4f" />

7.
<img width="907" height="707" alt="image" src="https://github.com/user-attachments/assets/01b3e946-245d-4bb1-9767-eb9a3c349d9a" />
<img width="1180" height="395" alt="image" src="https://github.com/user-attachments/assets/84084090-b6a8-4785-a2e9-d841e59274ba" />

Нефункциональное.
<img width="776" height="766" alt="image" src="https://github.com/user-attachments/assets/6a6cb9e3-46bc-46ea-bdfd-b02458ec6cb1" />
<img width="799" height="563" alt="image" src="https://github.com/user-attachments/assets/07cd59bd-3d62-4ecd-acaa-93e34326c595" />
<img width="636" height="306" alt="image" src="https://github.com/user-attachments/assets/74daa151-574f-4617-883a-10f09fb6e4c2" />
<img width="595" height="522" alt="image" src="https://github.com/user-attachments/assets/4ae06b43-e916-4402-88dc-db1ae495233c" />
<img width="741" height="201" alt="image" src="https://github.com/user-attachments/assets/fa7cd9ed-b53e-4300-a457-006cd90ad7e7" />
<img width="770" height="473" alt="image" src="https://github.com/user-attachments/assets/8b41d514-39e2-4260-8d48-b29f37c5c906" />
<img width="703" height="449" alt="image" src="https://github.com/user-attachments/assets/fd406966-fe61-422e-ada5-def44c60b095" />
<img width="689" height="517" alt="image" src="https://github.com/user-attachments/assets/cb3478cf-a664-40be-bbe9-d35fdc54c4a9" />
<img width="460" height="497" alt="image" src="https://github.com/user-attachments/assets/358cfca5-90a3-4267-befc-bdd82c61fd2d" />

