# Lab5-for-Java

Лабораторная работа 5. Вариант 6. Выполняла: Кужлева Любовь ИТ-17-2024/ИКНТ/ЛА8-2024/ПР4-2024.

Данная работа разделена на 7 блоков, каждый из который реализован с помощью конструкции switch. 
Каждое задание имеет полное описание для вывода на экран. 
В классе Main5 реализована работа программы с дружественным интерфейсом. 
В главном классе Main используется единственный метод класса Main5 для демонстрации работы программы.

1. Шаблон.
Используемые классы: SolveFraction, Fraction, FractionProxy.
В данном задании необходимо было добавить интерфейс к классу дроби, который релизует два новых метода:
получение вещественного значения, установка числителя и установка знаменателя.
Затем нужно было релизовать шаблон таким образом, чтобы можно было кэшировать дробь.
Для того, чтобы реализовать работу данного задания, я выбрала паттерн прокси (Proxy).
Идея паттерна «Заместитель(прокси)» заключается в предоставлении клиенту другого объекта (заместителя),
взамен объекту с контролируемым доступом. При этом, объект-заместитель, реализует тот-же интерфейс,
что и оригинальный объект, в результате чего, поведение клиента не требует изменений.
Иными словами, клиент взаимодействует с заместителем ровно как с оригинальным объектом посредством единого интерфейса.
Клиент, так же, не делает предположений о том работает ли он с реальным объектом или его заместителем.
Контролирование доступа к объекту, при этом, достигается за счет использования ссылки на него в заместителе,
благодаря которой заместитель переадресовывает внешние вызовы контролируемому объекту,
возможно сопровождая их дополнительными операциями.
Так, в классе FractionProxy используется ссылка на элемент класса SolveFraction.
В реализации класса FractionProxy также демонстрируется работа с кэшем,
для каждого шага работы задачи показано, полн ли кэш на данный момент или пуст.

2. Структурный шаблон.
Используемые классы: Cat,MeowManager,Meowing,CountingCatDecorator.
В данном задании необоходимо было посчитать количество мяуканьий кота
за всю работу задания, причем изменять уже реализованный класс нельзя.
Для того, чтобы реализовать рабоут данного задания, я выбрала паттерн декоратор (decorator).
Паттерн «Декоратор» позволяет динамически добавлять объекту новые обязанности,
не прибегая при этом к порождению классов. При этом, работа с подобной структурой
является более удобной и гибкой, нежели со множеством классов. Для этого, ссылка
на декорируемый объект помещается в другой класс, называемый «Декоратором».
Причем, и декоратор и декорируемый объект реализуют один и тот-же интерфейс,
что позволяет вкладывать несколько декораторов друг в друга, добавляя тем самым 
декорируемому объекту любое число новых обязанностей.
Декоратор переадресует внешние вызовы декорируему объекту сопровождая их наложением дополнительных обязанностей.
В реализации класса CountingCatDecorator добавляется новое поле meowCount,
подсчитывающее количество мяуканий при каждом вызове метода meow,
а также соответсвующий метод toString, который выводит количество мяуканий за всю работу задания.
  
3. Список.
Используемые классы: ListOfValues.
В данном задании необходимо было реализовать программу,
которая изменяет содержимое списка по определённому правилу.
Задача заключалась в том, чтобы в некотором списке L после
заданного элемента E вставить все элементы этого же списка,
но только в том случае, если элемент E действительно содержится в списке.
Метод, отвечающий за выполнение описанного действия, сначала ищет индекс
первого вхождения указанного элемента E в списке. Если элемент найден,
программа формирует несколько дополнительных списков: один содержит весь исходный список целиком,
второй — элементы, стоящие до элемента E, и третий — элементы, расположенные после него.
После этого исходный список очищается, а затем в него поочередно добавляются новые данные
в следующем порядке: сначала элементы, стоящие до элемента E, затем сам элемент E,
после него — весь исходный список целиком, и в конце — оставшиеся элементы, стоящие после E.
В результате программа формирует обновлённый список, который по сути содержит все прежние элементы,
но с вставкой полного списка после указанного элемента.
Таким образом, размер списка увеличивается примерно в два раза, сохраняя при этом исходный порядок элементов.
Если же элемент E отсутствует в списке, программа не выполняет никаких изменений,
и исходный список возвращается в первоначальном виде. 
Для реализации данной функциональности использовались обобщения (Generics).
Обобщённые типы и методы позволяют создавать универсальные и типобезопасные классы,
которые можно использовать с любыми типами данных, не теряя при этом гибкости и не дублируя код.

  
4. Мап
В данном задании необходимо было реализовать работу программы,
которая читает данные о студентах из текстового файла, сохраняет их в коллекцию
и выводит на экран список тех учащихся, которые соответствуют определённым условиям.
Файл, из которого производится чтение, называется Students.
В первой строке этого файла хранится количество студентов,
а в последующих строках содержатся сведения о каждом из них в формате:
фамилия, имя и три числовых значения, обозначающих количество баллов, набранных за экзамены. 
Программа открывает файл с помощью BufferedReader и FileReader, затем считывает первую строку,
преобразуя её в целое число, которое определяет, сколько записей о студентах нужно обработать.
После этого происходит последовательное чтение данных о каждом студенте.
Каждая строка разбивается на части методом split(" "), и из полученного массива строк формируется
полное имя студента и массив из трёх оценок. Эти данные помещаются в коллекцию типа HashMap,
где ключом является строка с именем студента, а значением — массив целых чисел с тремя оценками.
После того как все данные считаны и сохранены, программа проходит по элементам коллекции.
Для каждого студента вычисляется сумма трёх экзаменов, а также проверяется выполнение условий:
каждый экзамен должен иметь не менее 30 баллов, а общая сумма должна быть не меньше 140.
Если студент удовлетворяет этим критериям, его имя и фамилия выводятся на экран.
Одновременно подсчитывается количество студентов, соответствующих условиям отбора.
В конце работы программы выводится количество студентов, удовлятворяющих всем условиям.

5. Сет.
Используемые классы: Sets.
В данной задаче была реализована программа, которая позволяет определить,
какие буквы русского алфавита отсутствуют в заданном тексте.
Программа состоит из двух основных методов.
Метод getCharacters осуществляет чтение содержимого файла с помощью FileReader
и сохраняет все встречающиеся символы в множество Set<Character>.
Для корректной работы с русским текстом файл открывается с кодировкой UTF-8.
Содержимое файла читается посимвольно и формируется в строку, которая
затем преобразуется в нижний регистр, чтобы игнорировать различия между заглавными и строчными буквами.
После этого каждый символ добавляется в множество,
что позволяет получить уникальный набор всех символов, встречающихся в тексте.
Метод count использует полученное множество символов для анализа отсутствующих букв.
Сначала создаётся множество всех букв русского алфавита, после чего из него удаляются все символы,
присутствующие в тексте. В результате остаются только те буквы, которых нет в тексте.
Программа выводит на экран количество отсутствующих букв, а также сам список этих букв.
Использование коллекций Set позволило легко выполнять операции над множествами,
такие как удаление элементов одного множества из другого, что особенно удобно при работе с уникальными символами.
Кроме того, применение метода toLowerCase гарантирует,
что различие между заглавными и строчными буквами не повлияет на результат подсчета.

6. Очередь.
Используемые классы: Queues.
В данной задаче была реализована программа, которая позволяет по заданному списку
элементов построить очередь с определённой структурой.
Задача заключалась в том, чтобы по списку L сформировать очередь таким образом,
чтобы в начале находились элементы исходного списка, а после них — те же элементы,
расположенные в обратном порядке. Например, для списка [1, 2, 3] результатом должна была стать очередь [1, 2, 3, 3, 2, 1].
Для реализации данной функциональности был использован интерфейс Queue с конкретной реализацией через класс LinkedList,
который позволяет эффективно добавлять элементы в конец очереди и извлекать их с начала.
Метод buildQueue сначала создаёт очередь на основе исходного списка,
добавляя в неё все элементы в том порядке, в котором они находятся в списке.
Затем программа проходит по списку в обратном порядке и добавляет каждый элемент в конец очереди.
В результате формируется очередь, содержащая сначала исходные элементы, а затем их копии в обратном порядке.
Для вывода элементов очереди использовался вспомогательный метод showQueue,
который последовательно извлекает элементы с помощью метода poll и выводит их на экран.
При реализации использовались обобщённые типы (Generics), что позволило сделать
метод универсальным и применимым к спискам, содержащим элементы любого типа данных. 
  
7. Стрим.
Используемые классы: Point, Line, Polyline, BuildPolyline
1. В данном задании реализуется работа с набором объектов типа Point для построения ломаной линии,
представленной объектом типа Polyline. Основная цель заключается в том, чтобы из исходного списка
точек выбрать только уникальные точки с различными координатами,
упорядочить их по координате X и преобразовать отрицательные значения Y в положительные.
Для выполнения задачи используется класс BuildPolyline, метод которого принимает на вход список точек.
Внутри метода применяется Stream API, что позволяет удобно и лаконично выполнять последовательные операции над набором данных.
Сначала формируется поток точек, при этом все точки с отрицательными координатами Y преобразуются к положительным значениям.
Далее выполняется фильтрация для удаления повторяющихся точек с одинаковыми координатами X и Y.
После этого оставшиеся точки сортируются по координате X, а результат собирается в новый список объектов Point.
В конце метод возвращает объект типа Polyline.
Использование Stream API значительно упрощает реализацию:
операции фильтрации, сортировки и преобразования данных выполняются в виде цепочки вызовов.
Используемые классы: Stream2, humans*
2. В данном задании реализуется обработка текстового файла humans, который содержит данные в формате «Имя:Номер».
Цель программы заключалась в том, чтобы объединить данные по номерам, при этом имена
с одинаковыми номерами формировали список, а записи без номера исключались из обработки.
Для выполнения задачи используется класс Stream2, метод groupBy,
который считывает содержимое файла и формирует результат в виде Map,
где ключом выступает номер, а значением — список имён, соответствующих этому номеру.
Сначала с помощью Stream API происходит фильтрация данных: исключаются пустые строки и строки, не содержащие символ «:».
Далее каждая строка разделяется на две части, первая из которых соответствует имени, а вторая — номеру.
Для корректного представления имени применяется метод formatName, который приводит имя к нижнему регистру и делает первую букву заглавной.
После обработки данные собираются в мап, используя Collectors.groupingBy, где ключом становится номер, а значением — список имён, связанных с этим номером.
В результате получается структура, в которой все имена, относящиеся к одному номеру,
объединены в один список, а некорректные или неполные записи автоматически отбрасываются
*txt файл.

Тестирование.

Функциональное.

Нефункциональное.
